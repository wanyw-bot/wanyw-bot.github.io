<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Do you know JVM?</title>
    <url>/2020/07/26/Do-you-know-JVM/</url>
    <content><![CDATA[<h3 id="JVM概述"><a href="#JVM概述" class="headerlink" title="JVM概述"></a>JVM概述</h3><ul>
<li>什么是JVM呢？ </li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>redis学习笔记——redis企业解决方案</title>
    <url>/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="1-缓存预热"><a href="#1-缓存预热" class="headerlink" title="1 缓存预热"></a>1 缓存预热</h3><p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD1.PNG" alt="缓存预热1"></p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD2.PNG" alt="缓存预热2"></p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD3.PNG" alt="缓存预热3"></p>
<h3 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2 缓存雪崩"></a>2 缓存雪崩</h3><p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A91.PNG" alt="缓存雪崩1"></p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A92.PNG" alt="缓存雪崩2"></p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A93.PNG" alt="缓存雪崩3"></p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A94.PNG" alt="缓存雪崩4"></p>
<h3 id="3-缓存穿透"><a href="#3-缓存穿透" class="headerlink" title="3 缓存穿透"></a>3 缓存穿透</h3><p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F1.PNG" alt="缓存穿透1"></p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F2.PNG" alt="缓存穿透2"></p>
<p><img src="redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88//%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F3.PNG" alt="缓存穿透3"></p>
<h3 id="4-缓存击穿"><a href="#4-缓存击穿" class="headerlink" title="4 缓存击穿"></a>4 缓存击穿</h3><p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF1.PNG" alt="缓存击穿1"></p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF2.PNG" alt="缓存击穿2"></p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E4%BC%81%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF3.PNG" alt="缓存击穿3"></p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis学习笔记——redis高级</title>
    <url>/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h3 id="1-redis的持久化"><a href="#1-redis的持久化" class="headerlink" title="1 redis的持久化"></a>1 redis的持久化</h3><ul>
<li><p>什么是持久化</p>
<p>利用永久性存储介质对数据进行保存，并且在特定的时间点对数据进行恢复的工作机制称为持久化</p>
</li>
<li><p>为什么要持久化</p>
<p>由于redis中的数据存储在内存中，一旦发生掉电故障，那么可能会发生数据丢失，所以为了保障数据的完整性，需要持久化机制支持数据的恢复</p>
</li>
</ul>
<h4 id="1-1-持久化方法概述"><a href="#1-1-持久化方法概述" class="headerlink" title="1.1 持久化方法概述"></a>1.1 持久化方法概述</h4><pre><code>在redis中有两种持久化的方法：

RDB（redis database）和AOF（appendonlyfile）</code></pre><blockquote>
<p>RDB只存储某一时刻redis中某一数据库的全部数据，如若发生故障，在下一次redis重启时在dir指定目录    中读取redis.conf中指定的dump文件，将dump文件中的数据复制到redis主进程中，从而到达恢复数据的    目的。这种方法可能会导致一定的数据丢失，因为触发redis自动快照存储需要满足一定的条件</p>
</blockquote>
<blockquote>
<p>AOF根据redis.conf中指定的aof持久化策略，aof采用独立日志记录每次写命令的方法，将命令存储在aof格式文件中。如若发生故障，则在下次启动redis时，执行aof中所有的命令，以达到恢复数据的目的。这种方法保证了数据的完整性和持久化的实时性，使得数据的丢失量下降到一秒以内，是当下流行的持久化方法。</p>
</blockquote>
<h4 id="1-2-RDB"><a href="#1-2-RDB" class="headerlink" title="1.2 RDB"></a>1.2 RDB</h4><p>在redis中默认开启快照存储，redis中与RDB相关的配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启rdb文件的压缩，当为yes的时候，redis会采用LZF的压缩算法来对rdb文件进行压缩，这会消耗一定的CPU资源</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="comment"># 对rdb文件进行检验和检查 ，默认开启</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"><span class="comment"># 指定rdb文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment"># 在后台进程保存出错时停止redis主进程的写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="comment"># 重点配置！！ 当在以下时间间隔内发生预期内的数据变更操作数量时执行一次快照存储</span></span><br><span class="line">save 900 1 <span class="comment"># 900s内发生一次数据变更（set，del操作）</span></span><br><span class="line">save 300 10 <span class="comment"># 300s内发生10次数据变更</span></span><br><span class="line">save 60 10000 <span class="comment"># 60s内发生10000次数据变更</span></span><br></pre></td></tr></table></figure>

<p>在redis中的自动触发需满足如上条件，而在redis客户端也可以通过save/bgsave指令来手动触发快照存储</p>
<p>save和bgsave的区别在于：save整个操作是阻塞的，也就是说redis将当前数据快照存储在硬盘上的时候，主进程不能执行任何操作直到持久化完成，线上环境不建议使用；bgsave正是redis在检测环境满足条件后执行的持久化指令，稍后在EDB原理中会提到</p>
<p>特殊触发形式：debug reload /shutdown save 均会生成rdb文件</p>
<h5 id="快照存储原理"><a href="#快照存储原理" class="headerlink" title="快照存储原理"></a>快照存储原理</h5><p>在满足配置文件中的<save time change> 后，redis会执行一条bgsave的指令，若已有bgsave指令在执行过程中，则bgsave直接返回；如果没有，那么redis就会fork出一个子进程（注意fork操作会阻塞主进程，此时redis不能读写），这个子进程中包含redis主进程中所有的变量及数据，fork完成之后，子进程向主进程发送消息，主进程正常执行，而子进程则执行数据快照的存储。子进程将数据快照存储在一个临时文件中，在操作完成之后，将原来的dump文件替换为该临时文件（删除+重命名），同时向主进程发送消息。在有子进程执行RDB过程的时候，Redis主进程的读写不受影响，但是对于Redis的写操作不会同步到主进程的主内存中，而是会写到一个临时的内存区域作为一个副本，等到主进程接收到子进程完成RDB过程的消息后再将内存副本中的数据同步到主内存。</save></p>
<h5 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h5><p>优点：</p>
<pre><code>RDB持久化生成的文件较小，是一个紧凑压缩的二进制文件，占用的内存资源少，适用于定时备份和灾难恢复

RDB数据恢复速度较快</code></pre><p>缺点：</p>
<pre><code>RDB执行时需要fork出一个子进程，fork操作会阻塞redis服务主进程

RDB需要在满足一定条件下才能触发，所以一旦在未达到条件时发生掉电，宕机等情况，数据会有一定的丢失

RDB格式未统一，格式不兼容，数据移植有一定困难</code></pre><p>为了保证数据的完整性和持久化的实时性，产生了以日志方式记录写命令的AOF</p>
<h4 id="1-3-AOF"><a href="#1-3-AOF" class="headerlink" title="1.3 AOF"></a>1.3 AOF</h4><p>AOF在redis中默认不开启，AOF相关配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启AOF持久化</span></span><br><span class="line">appendonly yes </span><br><span class="line"><span class="comment"># 指定aof文件名</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"><span class="comment"># AOF的执行策略</span></span><br><span class="line">appendfsync always <span class="comment">#每执行一次写命令都执行一次AOF（如果对数据持久化的实时性要求特别高就采用此策略，但性能较低）</span></span><br><span class="line">appendfsync everysec<span class="comment">#每秒执行一次AOF，该策略为redis默认策略，最多会丢失一秒内的数据</span></span><br><span class="line">appendfsync no<span class="comment">#由系统决定何时执行AOF操作，不可控</span></span><br><span class="line">no-appendfsync-on-rewrite no <span class="comment"># 在进行aof重写时禁止执行主进程的指令存储</span></span><br><span class="line">auto-aof-rewrite-percentage 100 <span class="comment">#在当前aof文件的大小增长为原来的两倍时开启AOF重写</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb<span class="comment">#在当前aof文件的大小大于64mb时开启AOF重写</span></span><br><span class="line">aof-load-truncated yes<span class="comment">#在redis加载aof文件时出现no enough bytes的情况时截断此处数据</span></span><br></pre></td></tr></table></figure>

<h5 id="AOF的三种策略"><a href="#AOF的三种策略" class="headerlink" title="AOF的三种策略"></a>AOF的三种策略</h5><ul>
<li>always 指令的写入和保存均在主进程中执行</li>
<li>everysec 该策略会fork出一个子进程，在一秒内的写指令会被存储在redis为AOF持久化开辟的一个AOF缓冲区中，子进程每秒将缓冲区的指令追加在aof文件中</li>
<li>no 由系统执行AOF持久化，整个过程不可控</li>
</ul>
<blockquote>
<p>由于AOF采用独立日志记录写命令的方法来实现持久化，所以相比于RDB的方式，它产生aof文件的数据量也比较大，所以当aof文件达到一定大小时会发生AOF重写，该重写会降低aof文件的大小，redis的默认重写的条件是当aof文件的大小增长为原来的2倍且aof文件大小大于64mb时就执行一次重写操作。</p>
<p>AOF文件的压缩和RDB文件的压缩原理不一样，RDB文件的压缩是使用压缩算法将二进制的RDB文件压缩，而AOF文件的压缩主要是去除AOF文件中的无效命令，比如说：<br>- 同一个key的多次写入只保留最后一个命令<br>- 已删除、已过期的key的写命令不再保留</p>
</blockquote>
<p>AOF重写也分为手动和自动两种方式：</p>
<pre><code>手动：bgrewriteaof指令 自动：上述配置文件里的重写条件</code></pre><h5 id="AOF重写原理"><a href="#AOF重写原理" class="headerlink" title="AOF重写原理"></a>AOF重写原理</h5><ul>
<li><p>在执行bgrewriteaof指令时，若正在执行bgrewriteaof指令，则直接返回；若正在执行bgsave命令，则等待bgsave执行完毕后再执行。</p>
</li>
<li><p>redis会fork出一个子进程用于执行AOF的重写操作，fork操作同样阻塞</p>
</li>
<li><p>在子进程重写过程中不会影响主进程的AOF过程，包括指令写入AOF缓冲区以及缓冲区的指令数据写入硬盘</p>
</li>
<li><p>在此过程中，主进程仍可接受数据的读写命令，但写命令还要写入AOF重写缓冲区（与AOF缓冲区不一样，主进程指令数据完成持久化之后缓冲区的数据会被清空，但重写缓冲区为了记录重写时数据的前后差异只有在重写完成后，才会将数据移入AOF缓冲区。）</p>
</li>
<li><p>子进程的重写会将数据写入一个临时文件中，在重写完成后将主进程的AOF文件替换为该临时文件，会向主进程发送消息，同时将重写缓冲区数据移入AOF缓冲区</p>
<p> <em>*AOF重写的整个过程有三个部分会阻塞进程：</em><br><em>主进程fork子进程的时候</em><br><em>主进程把AOF重写缓冲区中的数据写到AOF缓冲区的时候</em><br> 使用新的AOF文件替换掉旧的AOF文件的时候*</p>
</li>
</ul>
<h4 id="1-4-RDB与AOF的区别与选择"><a href="#1-4-RDB与AOF的区别与选择" class="headerlink" title="1.4 RDB与AOF的区别与选择"></a>1.4 RDB与AOF的区别与选择</h4><p>redis会优先加载目录下的aof文件，如果没有则会加载rdb文件（优先级别：aof&gt;rdb)</p>
<p>否则就直接启动</p>
<ul>
<li>对数据非常敏感，建议使用AOF持久方案（默认每秒钟fsync一次，性能仍然很高）</li>
<li>数据呈现阶段有效性，建议使用RDB持久化方案（恢复速度快，rdb文件紧凑，占用内存小）</li>
<li>灾难恢复选用RDB（主从复制/备份）</li>
</ul>
<p>2 redis删除策略：定时/<strong>定期</strong>/惰性</p>
<ul>
<li><p>server.hz=10 每秒钟执行server.hz次操作 每一次操作遍历所有的数据库，对每一个数据库进行到期检查，每次遍历时间为250ms/server.hz,在每个数据库中随机挑选W个key，如果key超时，则删除；如果一次删除的key数量&gt;25%*W 循环该过程；否则该库的删除操作结束，转到下一个数据库</p>
</li>
<li><p>redis逐出算法（内存不够时执行此算法进行删除）</p>
</li>
</ul>
<h3 id="2-高级数据类型"><a href="#2-高级数据类型" class="headerlink" title="2  高级数据类型"></a>2  高级数据类型</h3><h4 id="2-1-bitmaps-setbit-key-offset-value"><a href="#2-1-bitmaps-setbit-key-offset-value" class="headerlink" title="2.1 bitmaps setbit key offset value"></a>2.1 bitmaps setbit key offset value</h4><p>将某一位设置为0/1</p>
<h4 id="2-2-HyperLogLog"><a href="#2-2-HyperLogLog" class="headerlink" title="2.2 HyperLogLog"></a>2.2 HyperLogLog</h4><p>用于基数统计的数据类型</p>
<p>pfadd key value1,value2</p>
<h4 id="2-3-GEO"><a href="#2-3-GEO" class="headerlink" title="2.3 GEO"></a>2.3 GEO</h4><p>用于定位的数据类型</p>
<p>geoadd key longtitude atitude member</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8源码解读系列——HashMap</title>
    <url>/2020/08/09/Java8%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94HashMap/</url>
    <content><![CDATA[<h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h3><p>HashMap是面试中最常问的内容之一，除此之外和它配套的还有ConcurrentHashMap(JDK1.5开始提供的一个适用于高并发的键值对数据结构)。在我们的日常学习（刷题）中，也免不了接触哈希表这种数据结构，所以使用上是没有问题的，但是面试官一般都喜欢怼源码，所以想要征服（吊打）面试官，HashMap的源码是一定要掌握。</p>
<h3 id="2-概览"><a href="#2-概览" class="headerlink" title="2 概览"></a>2 概览</h3><p>首先摆出HashMap的传统结构</p>
<p><img src="/2020/08/09/Java8%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94HashMap/HashMap%E4%BB%8B%E7%BB%8D.png" alt></p>
<p>其中的Entry的结构在Java中表现为这么一个接口</p>
<p><img src="/2020/08/09/Java8%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94HashMap/Map.Entry%E6%8E%A5%E5%8F%A3.png" alt></p>
<p>接下来我们直接看HashMap，发现它的Node节点类实现了Map.Entry接口 而HashMap中用于存储数据的空间即是Node数组提供的。</p>
<p><img src="/2020/08/09/Java8%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94HashMap/HashMap.Node.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>首先看到HashMap的类声明，HashMap继承自 AbstractMap，并且它实现了Map接口的各种通用操作，而 AbstractMap下还有很多子类，这里就不一一探究了。接下来看到源码中的一大段英文。</p>
<ul>
<li><pre><code>* This map usually acts as a binned (bucketed) hash table, but
* when bins get too large, they are transformed into bins of
* TreeNodes, each structured similarly to those in
* java.util.TreeMap. Most methods try to use normal bins, but
* relay to TreeNode methods when applicable (simply by checking
* instanceof a node).  Bins of TreeNodes may be traversed and
* used like any others, but additionally support faster lookup
* when overpopulated. However, since the vast majority of bins in
* normal use are not overpopulated, checking for existence of
* tree bins may be delayed in the course of table methods.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  HashMap在操作上比较像HashTable，HashTable是JDK1.2版本是提供的一个集合类，它同样支持键值对存储。但HashMap和HashTable不同的是：</span><br><span class="line"></span><br><span class="line">  - 允许空值空键（HashTable不允许）</span><br><span class="line">  - 非线程安全（在多线程下会出现数据覆盖的情况，而HashTable绝大多数方法都使用的synchronized独占锁来保证线程安全）</span><br><span class="line">  - 在JDK1.8中HashMap在每个槽位上的链长达到了8（TREEIFY_THRESHOLD）之后会转换成红黑树（根节点为TreeBin）</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
* &lt;p&gt;This implementation provides constant-time performance for the basic
* operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function
* disperses the elements properly among the buckets.  Iteration over
* collection views requires time proportional to the &quot;capacity&quot; of the
* &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number
* of key-value mappings).  Thus, it&apos;s very important not to set the initial
* capacity too high (or the load factor too low) if iteration performance is
* important.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  **注意**！！ HashMap的get和put操作时可以达到常数时间的即O(1)，有的面试官喜欢问这个，牢记</span><br><span class="line"></span><br><span class="line">  上述英文中提到了两个参数 capacity和load factor(加载因子) 这两个参数很重要 在初始化和扩容会提到</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
* &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
* as it is, generally speaking, impossible to make any hard guarantees in the
* presence of unsynchronized concurrent modification.  Fail-fast iterators
* throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.
* Therefore, it would be wrong to write a program that depended on this
* exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators
* should be used only to detect bugs.&lt;/i&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  截取了一段比较重要的注释 ：上面提到了迭代器的fail-fast机制(快速失败) hashmap不允许并发修改，但在这个无法提供硬保证，你不能依赖fail-fast机制来避免并发修改。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
Because TreeNodes are about twice the size of regular nodes, we
* use them only when bins contain enough nodes to warrant use
* (see TREEIFY_THRESHOLD). And when they become too small (due to
* removal or resizing) they are converted back to plain bins.  In
* usages with well-distributed user hashCodes, tree bins are
* rarely used.  Ideally, under random hashCodes, the frequency of
* nodes in bins follows a Poisson distribution
* (http://en.wikipedia.org/wiki/Poisson_distribution) with a
* parameter of about 0.5 on average for the default resizing
* threshold of 0.75, although with a large variance because of
* resizing granularity. Ignoring variance, the expected
* occurrences of list size k are (exp(-0.5) * pow(0.5, k) /
* factorial(k)). The first values are:
*
* 0:    0.60653066
* 1:    0.30326533
* 2:    0.07581633
* 3:    0.01263606
* 4:    0.00157952
* 5:    0.00015795
* 6:    0.00001316
* 7:    0.00000094
* 8:    0.00000006
* more: less than 1 in ten million
*
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  红黑树需要的子节点都为黑色 所以当链表转换为红黑树后，结点数翻倍。同时上面还提到了TREEIFY_THRESHOLD的值的由来</span><br><span class="line"></span><br><span class="line">接下来查看Hashmap中的一些比较重要的变量</span><br><span class="line"></span><br><span class="line">![图像 1](Java8源码解读系列——HashMap&#x2F;HashMap中的变量.png)</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line"></span><br><span class="line">- DEFAULT_INITIAL_CAPACITY为HashMap初始化容量 默认为16</span><br><span class="line">- 规定最大的许可容量为1&lt;&lt;30 2^30</span><br><span class="line">- DEFAULT_LOAD_FACTOR 默认加载因子 类型为float 大小为0.75f</span><br><span class="line">- TREEIFY_THRESHOLD 树化 (链表转红黑树)的阈值 规定为8</span><br><span class="line">- UNTREEIFY_THRESHOLD 链化 (红黑树退化成链表)的阈值 规定为6</span><br><span class="line">- MIN_TREEINFY_CAPACITY 默认树化时最小的容量 扩容时会提到</span><br><span class="line">- modCount 修改次数(添加和删除数据都算修改) 同时也是fail-fast机制的依据</span><br><span class="line"></span><br><span class="line">另外就是HashMap里的一大堆内部类 这里面只有部分需要提到TreeNode，Node</span><br><span class="line"></span><br><span class="line">###  3 HashMap的源码解读</span><br><span class="line"></span><br><span class="line">**以下table数组和Node数组均指HashMap内部存储数据的数组**！！</span><br><span class="line"></span><br><span class="line">#### 3.1 HashMap的初始化</span><br><span class="line"></span><br><span class="line">HashMap里共有四个构造器，如下图所示</span><br><span class="line"></span><br><span class="line">![](Java8源码解读系列——HashMap&#x2F;HashMap构造器.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其中HashMap()这个只是简单的给LOAD_FACTOR赋了下值，而HashMap(int)调用了HashMap(int,float)来进行初始化，我们重点关注其余两个。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Constructs an empty &lt;tt&gt;HashMap&lt;&#x2F;tt&gt; with the specified initial</span><br><span class="line"> * capacity and load factor.</span><br><span class="line"> *</span><br><span class="line"> * @param  initialCapacity the initial capacity</span><br><span class="line"> * @param  loadFactor      the load factor</span><br><span class="line"> * @throws IllegalArgumentException if the initial capacity is negative</span><br><span class="line"> *         or the load factor is nonpositive</span><br><span class="line"> *&#x2F;</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<p>可以看到：调用该构造器时，会先进行容量和负载因子的校验，它要保证容量在规定的容量范围（0~2^30）之内负载因子也必须正常。下面进入tableSizeFor方法查看threshold如何赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咋一看很混乱，我们带入数据看看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cap&#x3D;14 n&#x3D;13 n|&#x3D;n&gt;&gt;&gt;1&#x3D;15 ... n&#x3D;15 n&#x3D;n+1&#x3D;16 2^4</span><br><span class="line">cap&#x3D;5 n&#x3D;4 n|&#x3D;n&gt;&gt;&gt;1&#x3D;6 ... n&#x3D;8 2^3</span><br></pre></td></tr></table></figure>

<p>由此可以得出 返回的结果为比cap大的最小的2的整数倍 所以初始时刻的threshold的大小也为比cap大的最小的2的整数倍</p>
<h4 id="3-2-put操作"><a href="#3-2-put操作" class="headerlink" title="3.2 put操作"></a>3.2 put操作</h4><p>一般在我们创建好HashMap对象后，第一个进行的操作会是put操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到HashMap的put操作调用了putVal函数，期间调用hash函数获取键值对应在HashMap中的hash值</p>
<p>而hash函数如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span><br><span class="line"> * to lower.  Because the table uses power-of-two masking, sets of</span><br><span class="line"> * hashes that vary only in bits above the current mask will</span><br><span class="line"> * always collide. (Among known examples are sets of Float keys</span><br><span class="line"> * holding consecutive whole numbers in small tables.)  So we</span><br><span class="line"> * apply a transform that spreads the impact of higher bits</span><br><span class="line"> * downward. There is a tradeoff between speed, utility, and</span><br><span class="line"> * quality of bit-spreading. Because many common sets of hashes</span><br><span class="line"> * are already reasonably distributed (so don&#39;t benefit from</span><br><span class="line"> * spreading), and because we use trees to handle large sets of</span><br><span class="line"> * collisions in bins, we just XOR some shifted bits in the</span><br><span class="line"> * cheapest possible way to reduce systematic lossage, as well as</span><br><span class="line"> * to incorporate impact of the highest bits that would otherwise</span><br><span class="line"> * never be used in index calculations because of table bounds.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到只是对对象的hashcode进行了一个异或操作和null判别</p>
<p>继续查看putVal源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key 键值的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value 当节点存在值的时候不做修改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了之前的HashMap构造函数可以发现  真正用于存储数据的node数组并未创建，此时node数组为空</p>
<p>当tab为空时会执行resize()方法 进入resize()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Initializes or doubles table size.  If null, allocates in</span><br><span class="line"> * accord with initial capacity target held in field threshold.</span><br><span class="line"> * Otherwise, because we are using power-of-two expansion, the</span><br><span class="line"> * elements from each bin must either stay at same index, or move</span><br><span class="line"> * with a power of two offset in the new table.</span><br><span class="line"> *	初始化或使table数组倍增 如果为空的话会分配默认的数组容量</span><br><span class="line"> * @return the table</span><br><span class="line"> *&#x2F;</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;&#x2F;&#x2F;oldCap&#x3D;0</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">   &#x2F;&#x2F;如果原来的数组不为空 </span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果数组容量倍增后小于最大值并且原来的数组长度是不小于默认容量 则确定新的长度和阈值（均倍增）</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;初始阈值不为空 比如调用了HashMap(int,float)构造函数之后便可确定阈值</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">        &#x2F;&#x2F;否则为默认的容量和阈值</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line">    &#x2F;&#x2F;以上是确定newThr和newCap的过程 下面根据确定的容量创建Node数组</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table &#x3D; newTab;&#x2F;&#x2F;替换table</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    如果槽位上还是链表的结构 那么将一条链进行高地位拆分</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;&#x2F;&#x2F;低位链 loHead为头 loTail为尾</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;&#x2F;&#x2F;高位链 hiHead为头 hiTail为尾</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        &#x2F;&#x2F;高地位处理 rehash</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            loTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述过程我自己把它称为rehash</p>
<p><img src="/2020/08/09/Java8%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94HashMap/rehash1.png" alt></p>
<p><img src="/2020/08/09/Java8%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94HashMap/rehash2.png" alt></p>
<p>resize()方法结束后返回新的Node数组 并且如果以前的Node数组不为空，那么旧Node数组中的内容将被进行链上的高地位处理(rehash)，让我们再回到putVal方法，在resize()方法返回之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length; </span><br><span class="line"><span class="comment">//此时已经可以确保table数组被创建了 在整个HashMap中每个槽位都是通过hash&amp;(数组长度-1)来确定的</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//若当前槽位为空 当然直接填入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则说明当前槽位被其他数据占据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果占据槽位的节点的对象的hash值与当前键值对象的hash值相等 并且键是同一个对象或者经equals方法判定后相等 则说明当前槽位就是该键对象的槽位 后续直接更新键值对应的value就好</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果该槽位上的链已经转为了红黑树 那么便执行TreeNode的put逻辑 不再执行链状态的逻辑</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果为链状态 从头结点开始遍历 知道找到键对象对应的位置或空节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//binCount&gt;=7时进行树化(转为红黑树) 注意binCount为7 前面已经新建了一个节点 所以是当结点数大于等于8时进行树化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果某个节点的键对象经逻辑判断与当前键对象相等 保存当前节点引用</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行值的更新</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);<span class="comment">//该方法为空 留给子类实现(LinkedHashMap)</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//修改次数+1</span></span><br><span class="line">    ++modCount;</span><br><span class="line"><span class="comment">//该threshold是resize()时确定的阈值 一旦总的节点数大于阈值 就必须继续resize()</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">//该方法为空 留给子类实现(LinkedHashMap)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-如何从链表转为红黑树"><a href="#3-3-如何从链表转为红黑树" class="headerlink" title="3.3 如何从链表转为红黑树"></a>3.3 如何从链表转为红黑树</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//当tab数组的长度/容量小于最小的树化长度时 HashMap优先使用resize()的方法进行hash冲突的解决</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//否则执行链表向红黑树的转换</span></span><br><span class="line">    <span class="comment">//首先获取长度大于等于8的链表头节点(槽位)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//注意这一步 下面这步直接把原链替换成了TreeNode链</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先可以观察到 当tab数组的长度小于最小的树化长度时 HashMap优先使用resize()的方法解决hash冲突，而一旦tab数组的长度大于等于64  便执行树化的操作，那它如何进行树化的呢？继续查看replacementTreeNode源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// For treeifyBin</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法相当于把原节点包装成了一个新的Node对象 并且还将next设置为null。顺带提一下TreeNode和Node的继承关系</p>
<p>TreeNode继承关系如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment"> * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment"> * linked node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而LinkedHashMap.Entry&lt;K,V&gt;继承自HashMap.Node类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       Entry&lt;K,V&gt; before, after;</span><br><span class="line">       Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>回到treeifyBin源码，也就是说在上面这个do while循环中，把原链的节点全部包装为了TreeNode节点，<strong>注意是深度拷贝，和原链脱离了联系！</strong>。以上都是树化的准备，treeify()才是真正的树化操作，这个函数传入的是当前<strong>tab数组</strong>。</p>
<p>继续进入treeify查看源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">//从头结点往后遍历</span></span><br><span class="line">           <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">               next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">               x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   x.parent = <span class="keyword">null</span>;</span><br><span class="line">                   x.red = <span class="keyword">false</span>;</span><br><span class="line">                   初始时将头结点x作为根节点</span><br><span class="line">                   root = x;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   </span><br><span class="line">                   K k = x.key;</span><br><span class="line">                   <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                   Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">//此处往后去看红黑树吧。。各种自平衡的骚操作</span></span><br><span class="line">                   <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                       <span class="keyword">int</span> dir, ph;</span><br><span class="line">                       K pk = p.key;</span><br><span class="line">                       <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                           dir = -<span class="number">1</span>;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                           dir = <span class="number">1</span>;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                 (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                                (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                           dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                       TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                       <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           x.parent = xp;</span><br><span class="line">                           <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                               xp.left = x;</span><br><span class="line">                           <span class="keyword">else</span></span><br><span class="line">                               xp.right = x;</span><br><span class="line">                           root = balanceInsertion(root, x);</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           -----------------分割线-----------------</span><br><span class="line">           moveRootToFront(tab, root);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>发现结尾还有一个moveRootToFront方法,可以看到虽然传入了tab，但转为红黑树的过程中根本没用到tab数组，盲猜和最后的更换槽位节点有关，不能放过点进去瞅瞅 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that the given root is the first node of its bin.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//先明确变量 root为树化后的根节点 该节点不一定为first节点</span></span><br><span class="line">    <span class="comment">//tab还是为原数组 这个tab之前没有发生改变</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        <span class="comment">//将槽位的节点强转为TreeNode</span></span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        如果树化后root恰好为根节点，那自然不需要进行最后的节点变换</span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            tab[index] = root;<span class="comment">//槽位节点的更替</span></span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">            <span class="comment">//保证根节点在首节点 因为红黑树需要从根开始往叶子节点查找</span></span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-get操作"><a href="#3-4-get操作" class="headerlink" title="3.4 get操作"></a>3.4 get操作</h4><p>相比于put操作，get操作就好理解太多了，首先在执行get操作时会嵌套执行getNode函数，这个函数通过hash函数获取的hash值和键对象来定位在tab数组中的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">流程和put操作一致，首先判断槽位节点是否为定位的节点(前提不为空，如果为空就直接返回空了)，如果不是则判断当前节点是否为TreeNode类型的节点，即当前链是否已经出发了树化的操作，最后再执行链表上的遍历</span></span><br><span class="line"><span class="comment">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span></span><br><span class="line"><span class="comment">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span></span><br><span class="line"><span class="comment">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span></span><br><span class="line"><span class="comment">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span></span><br><span class="line"><span class="comment">        if (first.hash == hash &amp;&amp; // always check first node</span></span><br><span class="line"><span class="comment">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">            return first;</span></span><br><span class="line"><span class="comment">        if ((e = first.next) != null) &#123;</span></span><br><span class="line"><span class="comment">            if (first instanceof TreeNode)</span></span><br><span class="line"><span class="comment">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span></span><br><span class="line"><span class="comment">            do &#123;</span></span><br><span class="line"><span class="comment">                if (e.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                    return e;</span></span><br><span class="line"><span class="comment">            &#125; while ((e = e.next) != null);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return null;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<p>下一篇大概会分析ConcurrentHashMap的源码，顺便过一遍并发的知识点。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基础</title>
    <url>/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="1-Redis是什么"><a href="#1-Redis是什么" class="headerlink" title="1 Redis是什么"></a>1 Redis是什么</h3><p>Redis： Remote Dictionary Server 远程字典服务</p>
<p>Redis是一个基于ANSI C开发的一个基于键值对的高性能数据库</p>
<p>特征：</p>
<ul>
<li>数据之间没有必然关系（存储的数据为键值对）</li>
<li>使用单线程来执行所有命令</li>
<li>高性能 读:11万次/s 写:8万次/s</li>
<li>支持多种值类型：<ul>
<li>字符串</li>
<li>散列</li>
<li>列表</li>
<li>集合</li>
<li>排序集合</li>
</ul>
</li>
</ul>
<p>Redis的应用：</p>
<ul>
<li>热点信息的查询 （经常被访问的信息）</li>
<li>时效性信息（短信验证码）</li>
<li>实时信息显示</li>
<li>任务队列（Redis支持事务，执行的命令可放在事务的命令队列中）</li>
<li>分布式数据存储（session状态的存储）</li>
<li>分布式锁（setnx命令）</li>
</ul>
<h3 id="2-Redis基本操作"><a href="#2-Redis基本操作" class="headerlink" title="2 Redis基本操作"></a>2 Redis基本操作</h3><pre><code>预备知识：

清屏指令 clear

获取帮助指令 help [@group] group为组名 表示获取与该组有关的指令集 group可以为set，string等

退出指令 quit/exit/Esc</code></pre><h4 id="1-String类型"><a href="#1-String类型" class="headerlink" title="1 String类型"></a>1 String类型</h4><ul>
<li><p>信息添加/获取</p>
<p>set key value</p>
<p>get key(若key不存在则返回nil，即为空</p>
</li>
<li><p>设置时效</p>
<ul>
<li>setex key second value 时间过了second秒后数据失效</li>
<li>psetex key milillsecond value 时间过了second毫秒后数据失效</li>
</ul>
</li>
</ul>
<p>存储缓存数据和热点数据</p>
<p>统计PV（访问量）</p>
<h4 id="2-Hash类型-最多能添加2-32-1个field"><a href="#2-Hash类型-最多能添加2-32-1个field" class="headerlink" title="2 Hash类型 最多能添加2^32-1个field"></a>2 Hash类型 最多能添加2^32-1个field</h4><ul>
<li><p>信息添加修改/获取</p>
<p>hset key field value : hset user name stephen</p>
<p>hget user name 获取用户姓名</p>
<p>hdel user name 删除用户姓名</p>
</li>
</ul>
<p>应用场景：购物车的实现 每个用户都有唯一的购物车 field为商品的id value为数量</p>
<h4 id="3-List类型-最多能添加2-32-1的数据"><a href="#3-List类型-最多能添加2-32-1的数据" class="headerlink" title="3 List类型 最多能添加2^32-1的数据"></a>3 List类型 最多能添加2^32-1的数据</h4><ul>
<li>lpush key value</li>
<li>rpush key value</li>
<li>lget key index 获取指定下标的数据</li>
<li>lrange key start end 范围查询</li>
<li>lpop</li>
<li>rpop</li>
<li>lrem key count value移除指定数量的数据</li>
</ul>
<p>应用场景：日志队列的实现</p>
<h4 id="4-Set类型"><a href="#4-Set类型" class="headerlink" title="4 Set类型"></a>4 Set类型</h4><ul>
<li>sadd</li>
<li>smembers</li>
<li>srem key member</li>
<li>srandmember key [count] 随机选择指定数量的成员</li>
<li>spop 随机移除一个成员</li>
</ul>
<p>集合的交并补</p>
<p>sinter  key1 key2</p>
<p>sunion key1 key2</p>
<p>sdiff key1 key2</p>
<p>sinterstore  key1 key2 将结果存储在另外一个集合中</p>
<p>smove src des member将指定成员从src移到des</p>
<p>应用场景：权限校验/黑白名单</p>
<h4 id="5-Sorted-set类型"><a href="#5-Sorted-set类型" class="headerlink" title="5 Sorted_set类型"></a>5 Sorted_set类型</h4><ul>
<li>zadd key score member score member   score为member的权重</li>
<li>zrange key [WITHSCORE] 默认根据score由小到大排序显示结果</li>
<li>zrevrange 由大到小显示结果</li>
<li>zrem key member</li>
<li>zrangebyscore key min max [WITHSCORE] [LIMIT] 查询出权重在min和max之间的成员 同时还可以进行分页显示</li>
<li>zremrangebyrank key start end 按排名删除集合中名次在start和end之间的成员</li>
<li>zremrangebyscore key min max  </li>
<li>zrank key member 获取指定成员在集合中的索引</li>
<li>zrevrank key member 获取指定成员在倒序集合中的索引 </li>
<li>zscore key member </li>
</ul>
<p>应用场景：排行榜/时效性任务管理（如百度网盘的VIP体验加速，将当前用户暂时加入VIP用户集合中，一旦到达体验的时间便移除该用户</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis学习笔记——redis集群</title>
    <url>/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h3 id="1-主从复制简介"><a href="#1-主从复制简介" class="headerlink" title="1 主从复制简介"></a>1 主从复制简介</h3><p>互联网三高结构：高性能 高并发 高可用</p>
<h4 id="引言-单机redis的风险与问题"><a href="#引言-单机redis的风险与问题" class="headerlink" title="引言 单机redis的风险与问题"></a>引言 单机redis的风险与问题</h4><ul>
<li><p>机器故障</p>
<ul>
<li>硬盘故障，系统奔溃，redis服务器宕机</li>
<li>数据丢失，灾难性打击</li>
</ul>
</li>
<li><p>容量瓶颈</p>
<ul>
<li>单机redis内存不够用，只能升级内存</li>
</ul>
</li>
<li><p>成本太高</p>
</li>
</ul>
<p>结论：<br>  考虑使用多台服务器，多台服务器连接在一起并将数据同步，实现数据在各台服务器上的备份，当一台服务器出现故障时，其他的服务器能够继续提供服务，通过这种方法实现高可用</p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>为减少服务器之间信息的传递，redis在多个服务器中的选择一个服务器作为主计算机(master)，将其他服务器作为从计算机(slave) 主服务器负责读和写（通常把读操作关闭），而从计算机只负责读（通常把写操作关闭），当master和slave需要进行数据同步时，由master向其他slave进行数据同步。具体：当master中的数据发生变化时，master需要向其他slave进行数据同步，而主从复制则是master向slave进行有效的数据同步的过程</p>
<p><strong>主从复制的作用</strong></p>
<p>读写分离：master主要负责写数据 而slave主要负责读数据</p>
<p>负载均衡：基于主从结构，配合读写分离，master节点配合多个salve节点，根据需求调整salve节点的数量，让slave分担master节点的数据读取负载，从而提高redis的并发量和吞吐服务</p>
<p>故障恢复：当master节点或其他节点发生故障时，其余的任何节点都能顶替master继续提供服务</p>
<p>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</p>
<p><strong>主从复制的过程</strong></p>
<ol>
<li>建立连接阶段</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ol>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0.PNG" alt="主从复制过程概述"></p>
<h4 id="建立连接阶段"><a href="#建立连接阶段" class="headerlink" title="建立连接阶段"></a>建立连接阶段</h4><p>redis采用的是从服务器主动连接主服务器的方式，所以有以下几个阶段</p>
<ul>
<li>salve节点执行slaveof ip port命令表明该服务器是ip:port的slave节点</li>
<li>master节点收到指令，发送反馈信息</li>
<li>slave节点保存master节点的host和port</li>
<li>根据返回信息创建连接master的socket</li>
<li>同时执行周期性的ping操作以此确认master的存活状态</li>
<li>响应pong</li>
<li>salve返回器redis锁监听的端口</li>
<li>master节点保存端口号</li>
</ul>
<p>启动连接的方式：</p>
<pre><code>客户端发送slaveof ip port指令

服务器指定启动参数：--slaveof ip port

配置文件指定slaveof ip port</code></pre><h4 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h4><p>slave和master连接后也是由slave主动请求数据</p>
<ul>
<li>slave发起psync2同步数据请求</li>
<li>master收到该请求后将执行bgsave指令，将master中的所有数据转存为一个rdb文件</li>
<li>通过socker将rdb文件发送给slave</li>
<li>此后master接受到的写指令会被放在master的复制缓冲区中，该缓冲区在第一个slave连接时被创建，用于接受数据同步后的master的写指令</li>
<li>slave节点接受rdb文件后会清空自身原有的数据 执行rdb文件恢复过程（至此为全量复制），操作完成后向master发送同步成功消息</li>
<li>随后master会将复制缓冲区中的指令数据发送给slave节点 slave收到数据后执行bgrewriteaof操作对数据进行重写（部分复制）</li>
</ul>
<p>注意：</p>
<pre><code>master节点：

    数据同步阶段应该避免高峰期，防止由执行bgsave带来过长的阻塞时间

    复制缓冲区不宜设置的太小 缓冲区溢出会引起循环的全量复制操作

    配置参数：repl-backlog-size 1mb  默认大小为1mb

slave节点：

    关闭该节点对外服务：slave-serve-stale-data no|yes

    多个slave节点请求master数据时 master传输的数据量很大 会降低网络中的可用带宽 需错峰

    slave过多时，建议调整拓扑结构（将某些slave提升为某些节点的master，通过这些master来进行数据同步，但会产生一定的延时）以此分担master同步数据的压力</code></pre><h4 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h4><p>在进行数据同步后（全量复制与部分复制），master节点数据仍然会发生变化，所以在此期间要不断的进行数据同步，这个时候的同步采用的是命令传播的方式，在master上会维护一个复制积压缓冲区（即前面说的复制缓冲区），复制缓冲区可以把其作为一个FIFO的队列，队列中以AOF文件的格式记录后续的写命令，如下图：</p>
<table>
<thead>
<tr>
<th>0x11</th>
<th>0x12</th>
<th>0x13</th>
<th>0x14</th>
<th>0x15</th>
<th>0x16</th>
<th>0x17</th>
<th>0x18</th>
<th>offset</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>3</td>
<td>\n</td>
<td>\r</td>
<td>s</td>
<td>e</td>
<td>t</td>
<td>…</td>
<td>data</td>
</tr>
</tbody></table>
<p>每一个数据都是一个字节，并且以offset来定位数据。master将复制积压缓冲区的内容传输给slave节点后，slave便执行aof重写后将数据进行同步</p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E8%BF%87%E7%A8%8B.PNG" alt></p>
<p>psync2 同数据同步阶段，在slave第一次请求同步时，slave中没有存储offset，所以发送一条psync2 ？ -1的指令来请求同步，后续同步时带上自己的runid和保存的offset</p>
<p>在命令传播阶段时，slave定期的发送replconf ack offset来检测数据是否发生变化，定期发送由心跳机制维护</p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E5%BF%83%E8%B7%B3.PNG" alt></p>
<h4 id="如何避免全量复制"><a href="#如何避免全量复制" class="headerlink" title="如何避免全量复制"></a>如何避免全量复制</h4><p>内部策略：为了保证master的runid与offset在重启前后一致，master在关闭时执行shutdown save的指令。将offset和runid持久化到rdb文件中，在下次启动时将runid和offset重新复制给当前的runid和offset，所有的slave都会认为master没有发生变化</p>
<p>确定合适的缓冲区：repl-backlog-size 1mb 复制缓冲区的大小定制的过小也会造成频繁的全量复制</p>
<p>缓冲区设置如下：估算slave与master重连的平均时长；估算master每秒写命令的数量；缓冲区大小：2*sencond*count</p>
<h4 id="发生频繁的网络中断如何处理"><a href="#发生频繁的网络中断如何处理" class="headerlink" title="发生频繁的网络中断如何处理"></a>发生频繁的网络中断如何处理</h4><p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD1.PNG" alt></p>
<p>设置参数repl-timeout 默认时长时60s 超过60s则将slave释放掉</p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD2.PNG" alt="网络中断2"></p>
<h3 id="2-哨兵"><a href="#2-哨兵" class="headerlink" title="2 哨兵"></a>2 哨兵</h3><p>哨兵是一个分布式系统，用于对主从结构中的redis服务器进行监控，当出现故障时使用投票机制选出新的master并且将slave节点连接到新的master上。</p>
<p>作用：</p>
<pre><code>监控</code></pre><ul>
<li><p>不断检测master和slave是否正常运行</p>
<p>  通知</p>
</li>
<li><p>当监控的服务器出现问题时，向其他（哨兵，服务器）发送通知，master上线后也需要发送通知</p>
<p>  故障转移</p>
</li>
<li><p>当master出现故障后，slave断开与master的连接，并且挑选出一个slave作为master，并将slave连接到该master上</p>
</li>
</ul>
<h4 id="哨兵配置"><a href="#哨兵配置" class="headerlink" title="哨兵配置"></a>哨兵配置</h4><p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E5%93%A8%E5%85%B51.PNG" alt="哨兵1"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认监控 127.0.0.1:6379 当有2个哨兵意见一致时哨兵生效</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"><span class="comment"># 经过多少秒才判定服务器下线 默认30s</span></span><br><span class="line">sentinel down-after-miliseconds mymaster 30000</span><br><span class="line"><span class="comment"># 执行并行同步的线程数量</span></span><br><span class="line">sentinel parallel-sycns mymaster 1</span><br><span class="line"><span class="comment"># 经过多少秒才判定同步失败 默认3分钟</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>

<h4 id="哨兵监控过程"><a href="#哨兵监控过程" class="headerlink" title="哨兵监控过程"></a>哨兵监控过程</h4><p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E5%93%A8%E5%85%B52.PNG" alt="哨兵2"></p>
<ol>
<li>哨兵向配置文件中监控的主机发起info命令 获取master和slave以及sentinel等一系列信息</li>
<li>为了方便后续的命令交互，哨兵与所有服务器建立一个cmd连接</li>
<li>哨兵继续向slave发送info命令  获取slave的详细信息</li>
<li>后续的哨兵向master发送info命令时 会感知到有其他哨兵在监控 该哨兵会与之前监控的哨兵建立发布/订阅的信息通道用来进行各个哨兵之间的同步，来保证数据的一致性</li>
</ol>
<p>哨兵通知过程</p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E5%93%A8%E5%85%B53.PNG" alt="哨兵3"></p>
<p>sentinel不断地向服务器发送hello命令 以此来确定服务器的存活状态，一个哨兵hello执行后获取返回的信息通过过publish|subscribe机制在哨兵之间传递 之后所有哨兵可获取服务器的状态</p>
<h4 id="故障转移过程"><a href="#故障转移过程" class="headerlink" title="故障转移过程"></a>故障转移过程</h4><ul>
<li>当一个哨兵发出hello命令后得不到返回并且一直持续了down-aftermilisecond 秒后 该哨兵将该台服务器置为主观下线状态。</li>
</ul>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E5%93%A8%E5%85%B55.PNG" alt></p>
<ul>
<li>该哨兵将服务器下线的通知在哨兵集群内进行传递，其余哨兵也执行对该台服务器的状态确认（发送hello命令），当有超过半数（通过配置亦可指定）的哨兵确认主观下线后，该服务器状态转为客观下线。</li>
<li>为了避免繁琐和复杂的操作，哨兵之间需通过投票机制选举出“一位代表”来确定新的master。具体操作为： 每台哨兵在哨兵内网中发送自己的投票信息，哨兵既作为投票者也作为参选者，投票信息包括要出故障的服务器信息，自身的runid以及参与竞选的次数（如果一轮未决出，则继续下一轮投票）</li>
<li>master的选择条件：<ul>
<li>在线的</li>
<li>响应快的</li>
<li>与原master连接时间最近的</li>
<li>优先原则<ul>
<li>offset（偏移量较小的）</li>
<li>runid较小的</li>
</ul>
</li>
</ul>
</li>
<li>新的master选举出来后，哨兵代表向新的master发送一条指令（slaveof no one）断开所有连接</li>
<li>向其他的服务器发送一条（slaveof ip port）新master的ip和端口</li>
</ul>
<h3 id="3-集群"><a href="#3-集群" class="headerlink" title="3 集群"></a>3 集群</h3><p>定义：使用网络将多台计算机连接起来提供统一的服务并提供统一的管理方式，对外仍然表现为单机的形式</p>
<p><strong>redis集群机构设计</strong></p>
<ul>
<li>redis集群存储结构设计</li>
</ul>
<p>redis将每个redis16384个的数据槽，每个槽位可以存放多个数据，即将多个redis进行分区，当外部请求存放数据时，首先通过CRC16算法计算出一个校验和，再对16384进行取模操作得到该数据应存放的槽位，整个过程是对键值到槽位的一个映射过程。</p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E8%AE%BE%E8%AE%A11.PNG" alt></p>
<ul>
<li>redis集群通讯设计</li>
</ul>
<p>为了加快定位数据的速度，redis服务器之间相互通讯，每个服务器中都有着一张记录所有服务器拥有槽位情况的表，在取模操作完成后首先去查接受到该请求的redis服务器中有没有该槽位，如果没有，则给出拥有该槽位的redis服务器地址，进而重新发起请求</p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E9%9B%86%E7%BE%A4%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1.PNG" alt="redis集群通讯设计"></p>
<p>redis集群搭建</p>
<ul>
<li>首先启动六个redis服务，每个redis监听不同的端口，在此之前需修改其配置文件，让每个redis-server进程都开启支持集群的配置</li>
</ul>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B02.PNG" alt></p>
<p>添加如上配置内容后开启服务节点 在开启所有节点后 开始创建集群</p>
<ul>
<li><p>创建命令为 redis-cli –cluster create ip:port … –cluster-replicas num(num为每个master的slave节点的数量)</p>
</li>
<li><p>创建完成后会显示出每个master节点分配的槽位数量以及范围（注意：slave节点并不占有槽位，它只与master节点进行数据同步操作来保持数据一致性）</p>
</li>
</ul>
<p>对集群进行测试</p>
<p><img src="/2020/07/30/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94redis%E9%9B%86%E7%BE%A4/%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B01.PNG" alt></p>
<p><strong>redis的集群分区</strong>:</p>
<p>最主要的目的都是在移除、添加一个节点时对已经存在的缓存数据的定位影响尽可能的降到最小。redis将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点， 比如说：</p>
<ul>
<li><p>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</p>
</li>
<li><p>与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</p>
</li>
</ul>
<p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在 节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线，从而保证集群的可用性。下面我们就来学习下集群中节点的增加和删除。</p>
<p>redis集群的节点添加和移除操作</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识review</title>
    <url>/2020/08/24/MySQL%D6%AA%CA%B6review/</url>
    <content><![CDATA[<h3 id="MySQL知识review"><a href="#MySQL知识review" class="headerlink" title="MySQL知识review"></a>MySQL知识review</h3><h4 id="1-基表与视图"><a href="#1-基表与视图" class="headerlink" title="1 基表与视图"></a>1 基表与视图</h4><p>关系称为表，是关系数据库的基本组成单位。在SQL中，表分为两种：</p>
<ul>
<li><p>基表：数据<code>显式地存储</code>在数据库中</p>
</li>
<li><p>视图：视图是个<code>虚表</code>。<strong>仅有逻辑定义，可根据其定义由其它表（视图）导出，但不作为一个表显式地存储在数据库中。</strong>视图可像基表一样，参与各种数据库操作。</p>
<ul>
<li><p>临时视图</p>
<p>  <strong>对于较复杂的查询，可将查询中相对独立部分作为查询的中间结果，定义为临时视图。</strong>临时视图在功能上与普通视图一样，但仅用于附在临时视图定义后的查询语句中。该查询语句结束后，临时视图随之自行消失</p>
</li>
<li><p>普通视图</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/08/24/MySQL%D6%AA%CA%B6review/MySQL%E7%9F%A5%E8%AF%86review/SQL%E4%B8%80%E8%88%AC%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="SQL支持的数据类型"></p>
<h4 id="2-基表模式的修改"><a href="#2-基表模式的修改" class="headerlink" title="2 基表模式的修改"></a>2 基表模式的修改</h4><h5 id="2-1-增加列"><a href="#2-1-增加列" class="headerlink" title="2.1 增加列"></a>2.1 增加列</h5><blockquote>
<p>ALTER TABLE [&lt;表的创建者名&gt;]&lt;表名&gt; ADD &lt;列名&gt; &lt;类型&gt;</p>
</blockquote>
<h5 id="2-2-删除基表"><a href="#2-2-删除基表" class="headerlink" title="2.2 删除基表"></a>2.2 删除基表</h5><blockquote>
<p>DROP TABLE &lt;表名&gt;</p>
</blockquote>
<h5 id="2-3-补充定义主键"><a href="#2-3-补充定义主键" class="headerlink" title="2.3 补充定义主键"></a>2.3 补充定义主键</h5><blockquote>
<p>ALTER TABLE &lt;表名&gt;  ADD PRIMARY KEY （&lt;列名表&gt;)</p>
</blockquote>
<h5 id="2-4-撤销主键定义"><a href="#2-4-撤销主键定义" class="headerlink" title="2.4  撤销主键定义"></a>2.4  撤销主键定义</h5><p>一般情况下，一个基表如果已定义了主键，则系统会在主键上自动建立索引。当插入新行时 ，系统会进行主键唯一性检查，这样，当进行大量的插入操作时，势必影响系统效率。</p>
<blockquote>
<p>ALTER TABLE &lt;表名&gt; DROP PRIMARY KEY ;</p>
</blockquote>
<h5 id="2-5-补充定义外键"><a href="#2-5-补充定义外键" class="headerlink" title="2.5 补充定义外键"></a>2.5 补充定义外键</h5><blockquote>
<p>ALTER TABLE &lt;表名-1&gt; ADD FOREIGN KEY [&lt;外键名&gt;]（&lt;列名表&gt;）REFERENCES  &lt;表名-2&gt;<br>   [ON DELETE { RESTRICT | CASCADE |SET NULL}]; </p>
</blockquote>
<h5 id="2-6-撤销外键定义"><a href="#2-6-撤销外键定义" class="headerlink" title="2.6  撤销外键定义"></a>2.6  撤销外键定义</h5><blockquote>
<p>ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键名&gt; ;</p>
</blockquote>
<h4 id="3-索引建立与删除"><a href="#3-索引建立与删除" class="headerlink" title="3 索引建立与删除"></a>3 索引建立与删除</h4><p><img src="/2020/08/24/MySQL%D6%AA%CA%B6review/MySQL%E7%9F%A5%E8%AF%86review/%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B.png" alt="数据库索引建立"> </p>
<p>索引的建立有多种途径，既可以在创建表时指定索引，也可以在创建表后修改表结构添加索引，还可以直接使用CREATE INDEX的命令来创建索引。</p>
<ul>
<li><p>创建表时指定索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`table`</span> (</span><br><span class="line">	<span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT ,</span><br><span class="line">	<span class="string">`title`</span> <span class="built_in">char</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">	<span class="string">`content`</span> <span class="built_in">text</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="literal">NULL</span> ,</span><br><span class="line">	<span class="string">`time`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">	<span class="keyword">INDEX</span> tindex(title[<span class="keyword">ASC</span>],<span class="keyword">column</span>[<span class="keyword">DESC</span>]...)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表结构添加索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">table</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> tindex(title[<span class="keyword">ASC</span>],<span class="keyword">column</span>[<span class="keyword">DESC</span>]...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接使用CREATE INDEX的命令来创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> tindex <span class="keyword">ON</span> <span class="keyword">table</span>(title[<span class="keyword">ASC</span>],<span class="keyword">column</span>[<span class="keyword">DESC</span>]...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON &lt;table_name&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-基本SQL查询语言"><a href="#4-基本SQL查询语言" class="headerlink" title="4 基本SQL查询语言"></a>4 基本SQL查询语言</h4><p><img src="/2020/08/24/MySQL%D6%AA%CA%B6review/MySQL%E7%9F%A5%E8%AF%86review/%E5%9F%BA%E6%9C%ACSQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5.png" alt="基本SQL查询语句"></p>
<ul>
<li>SELECT——指出要查询的项目，通常指列名或表达式，是必需的。</li>
<li>FROM——指明被查询的表或视图名，是必需的。 </li>
<li>WHERE ——说明查询条件，是任选的。 </li>
<li>GROUP BY——将表按列的值分组，是任选的。 </li>
<li>ORDER BY——将查询结果排序，是任选的。</li>
</ul>
<p><img src="/2020/08/24/MySQL%D6%AA%CA%B6review/MySQL%E7%9F%A5%E8%AF%86review/%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6.png" alt="查询条件"></p>
<h4 id="5-数据操纵语言"><a href="#5-数据操纵语言" class="headerlink" title="5 数据操纵语言"></a>5 数据操纵语言</h4><p>SQL提供了增、删、改数据库中数据的语句，分别介绍如下。</p>
<h5 id="5-1-Insert-语句"><a href="#5-1-Insert-语句" class="headerlink" title="5.1 Insert 语句"></a>5.1 Insert 语句</h5><p><img src="/2020/08/24/MySQL%D6%AA%CA%B6review/MySQL%E7%9F%A5%E8%AF%86review/%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5.png" alt="Insert语句"></p>
<h5 id="5-2-Delete语句"><a href="#5-2-Delete语句" class="headerlink" title="5.2 Delete语句"></a>5.2 Delete语句</h5><p><img src="/2020/08/24/MySQL%D6%AA%CA%B6review/E:%5Cwanyw-blog%5Csource_posts%5C2020%5C08%5C24%5CMySQL%E7%9F%A5%E8%AF%86review%5C%E5%88%A0%E9%99%A4%E8%AF%AD%E5%8F%A5.png" alt="Delete语句"></p>
<h5 id="5-3-Update语句"><a href="#5-3-Update语句" class="headerlink" title="5.3 Update语句"></a>5.3 Update语句</h5><p><img src="/2020/08/24/MySQL%D6%AA%CA%B6review/MySQL%E7%9F%A5%E8%AF%86review/%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5.png" alt="Update语句"></p>
<h4 id="6-视图"><a href="#6-视图" class="headerlink" title="6 视图"></a>6 视图</h4><h5 id="6-1-普通视图"><a href="#6-1-普通视图" class="headerlink" title="6.1 普通视图"></a>6.1 普通视图</h5><p>   视图：是由其它视图或基表导出的虚表。它不是一个存在数据库中的表，而是在数据目录中保留其逻辑定义。</p>
<p>当视图参与数据库操作时，可通过修改查询条件，把对视图的查询转换为对基表的查询。</p>
<h5 id="6-2-视图的定义"><a href="#6-2-视图的定义" class="headerlink" title="6.2 视图的定义"></a>6.2 视图的定义</h5><p>视图可用于一些经常要查询的数据，<strong>视图对应的内容总是实时、最新的内容，并不是视图定义时对应内容。这是由于基表随着更新操作其内容在不断变化，所以视图对应的内容也在不断变化</strong></p>
<h5 id="6-3-视图的撤销"><a href="#6-3-视图的撤销" class="headerlink" title="6.3 视图的撤销"></a>6.3 视图的撤销</h5><p>视图不再需要时，可以从系统中撤消</p>
<h5 id="6-4-视图创建与撤销"><a href="#6-4-视图创建与撤销" class="headerlink" title="6.4 视图创建与撤销"></a>6.4 视图创建与撤销</h5><p><img src="/2020/08/24/MySQL%D6%AA%CA%B6review/MySQL%E7%9F%A5%E8%AF%86review/%E8%A7%86%E5%9B%BE%E5%88%9B%E5%BB%BA.png" alt="视图创建"> </p>
<h5 id="6-5-视图更新"><a href="#6-5-视图更新" class="headerlink" title="6.5 视图更新"></a>6.5 视图更新</h5><p>视图更新是一个较复杂的问题。通常都加以限制： </p>
<ul>
<li>由一个基表定义的视图，只有含有基表的主键或候补键，并且视图中没有用表达式或函数定义的属性，才允许更新。</li>
<li>由多表连接所定义的视图不允许更新。</li>
<li>定义中用到GROUP BY子句或聚集函数的视图不允许更新。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络复习</title>
    <url>/2020/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1 物理层"></a>1 物理层</h4><h5 id="1-1-物理层的任务及定义"><a href="#1-1-物理层的任务及定义" class="headerlink" title="1.1 物理层的任务及定义"></a>1.1 物理层的任务及定义</h5><p>物理层的主要任务<strong>以在两个网络设备之间提供透明的比特流传输</strong></p>
<p>OSI的物理层定义：物理层提供<strong>机械的、电气的、功能的和规程的特性</strong>，目的是启动、维护和关闭数据链路实体之间进行比特传输的物理连接。</p>
<ul>
<li>机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等</li>
<li>电气特性：指明在接口电缆的各条线上出现的电压的范围。即什么样的电压表示l或0。传输速度、最大传输距离</li>
<li>功能特性：指明某条线上出现的某一电平的电压表示何种意义，  定义各条物理线路的功能。（数据，控制，接地，定时）</li>
<li>规程特性：指明对于不同功能的各种可能事件的出现顺序。主要定义各条物理线路的工作规程和时序关系。 </li>
</ul>
<h4 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2 数据链路层"></a>2 数据链路层</h4><p>信道：向某个方向传输信息的媒体</p>
<p>数据链路层使用的信道类型：</p>
<ul>
<li>点对点信道 这种信道使用一对一的点到点的通信方式 常用协议：PPP(Point To Point)</li>
<li>广播信道 使用一对多的广播通信方式</li>
</ul>
<p><strong>数据链路层的三个基本问题</strong></p>
<blockquote>
<p>封装成帧、透明传输、差错检测</p>
</blockquote>
<h5 id="2-1-PPP协议-点对点协议-通常用于用户接入因特网"><a href="#2-1-PPP协议-点对点协议-通常用于用户接入因特网" class="headerlink" title="2.1 PPP协议(点对点协议) 通常用于用户接入因特网"></a>2.1 PPP协议(点对点协议) 通常用于用户接入因特网</h5><p><strong>ppp协议的组成</strong></p>
<ul>
<li>将IP数据包封装到链路层的方法，PPP协议既支持异步也支持同步链路</li>
<li>一个用来建立、配置和测试数据链路连接的链路控制协议（LCP-Link Control Protocol）</li>
<li>一套网络控制协议(NCP)</li>
</ul>
<p>PPP帧格式如下：</p>
<p><img src="/2020/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/PPP%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt></p>
<h4 id="3-使用广播信道的数据链路层"><a href="#3-使用广播信道的数据链路层" class="headerlink" title="3 使用广播信道的数据链路层"></a>3 使用广播信道的数据链路层</h4><p>局域网最主要的特点：网络为一个单位所拥有，且地理范围和站点数目均有限。</p>
<p>主要优点：</p>
<ul>
<li>具有广播功能，处于局域网上的计算机可以共享连接在局域网上的各种硬件和软件资源</li>
<li>便于系统的拓展和演变，各设备的位置可灵活调整</li>
<li>提高了系统的可靠性和可用性</li>
</ul>
<h5 id="3-1-共享信道技术"><a href="#3-1-共享信道技术" class="headerlink" title="3.1 共享信道技术"></a>3.1 共享信道技术</h5><ul>
<li>静态划分信道，如频分复用、波分复用和码分复用等，当一个用户分配到了一条信道之后，就不会产生冲突，但这种静态划分信道的方式代价太大。</li>
<li>动态媒体随机接入，信道并非固定分配给某个用户<ul>
<li>随机接入 需要解决多个用户发送信息时产生信息碰撞的问题 如传统的以太网技术</li>
<li>受控接入 用户发送信息必须遵循一定的控制 如令牌环局域网：只有当用户获取了令牌帧之后才能够发送信息，这种技术使用的较少</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap源码解读</title>
    <url>/2020/09/06/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h3 id="ConcurrentHashMap源码解读"><a href="#ConcurrentHashMap源码解读" class="headerlink" title="ConcurrentHashMap源码解读"></a>ConcurrentHashMap源码解读</h3><h4 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h4><p>ConcurrentHashMap是</p>
<h4 id="二、ConCurrentHashMap主要方法解读"><a href="#二、ConCurrentHashMap主要方法解读" class="headerlink" title="二、ConCurrentHashMap主要方法解读"></a>二、ConCurrentHashMap主要方法解读</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//spread方法和hashmap中的hash方法类似 但concurrentHashmap不允许有空值空键</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//CAS 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//使用延迟初始化 只有当使用map时才初始化</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//若首节点为空(通过sun.misc.Unsafe类来查询，保证是原子的)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//使用cas的方式实现空槽位的插入</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然ConcurrentHashMap采用了和hashmap一样的延迟初始化，那么在这个支持高并发的集合里，它的初始化操作又有什么不一样呢？继续跟踪源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//initTable 方法</span></span><br><span class="line">Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//sizeCtl&lt;0 当前线程放弃初始化 -1表示正在初始化过程中 所以tab只初始化一次</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//尝试CAS将sc设置为-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//初始化后sizeCtl为阈值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br></pre></td></tr></table></figure>



<p>接着查看putVal方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若当前该节点上的链正在resize(通过首节点是否为ForwardNode类型来判定) </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">    <span class="comment">//帮助转移</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure>

<p>继续跟踪helpTransfer方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helps transfer if a resize is in progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">            V oldVal &#x3D; null;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                    if (fh &gt;&#x3D; 0) &#123;</span><br><span class="line">                        binCount &#x3D; 1;</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal &#x3D; e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val &#x3D; value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount &#x3D; 2;</span><br><span class="line">                        if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) !&#x3D; null) &#123;</span><br><span class="line">                            oldVal &#x3D; p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val &#x3D; value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (binCount !&#x3D; 0) &#123;</span><br><span class="line">                if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal !&#x3D; null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>测试草稿</title>
    <url>/2023/10/03/%E6%B5%8B%E8%AF%95%E8%8D%89%E7%A8%BF/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
